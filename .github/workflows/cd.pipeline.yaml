name: CD Pipeline

on:
  repository_dispatch:
    types: [start-cd-pipeline]
  workflow_dispatch: # מאפשר הפעלה ידנית
    inputs:
      version:
        description: 'Version to deploy'
        required: false
        default: 'latest'

jobs:
  deploy:
    name: 'Deploy to AKS'
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: 'v3.12.0'

    - name: Get AKS Credentials
      run: |
        # התחברות לקלאסטר AKS
        az aks get-credentials --resource-group orel-neto-project --name gifapp-aks --admin
        kubectl get nodes

    - name: Deploy Monitoring Stack
      run: |
        # הוספת מאגרי Helm הדרושים
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        helm repo add grafana https://grafana.github.io/helm-charts
        helm repo update

        # יצירת namespace למוניטורינג
        kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

        # יצירת קובץ ערכים לעדכון הגדרות המוניטורינג עבור Azure
        cat > ./helm/monitoring/azure-values.yaml << EOF
        grafana:
          enabled: true
          adminPassword: admin
          service:
            type: LoadBalancer
          persistence:
            enabled: true
            storageClassName: "managed-premium"
            size: 1Gi

        prometheus:
          prometheusSpec:
            retention: 15d
            serviceMonitorSelectorNilUsesHelmValues: false
            serviceMonitorSelector: {}
            resources:
              requests:
                memory: 256Mi
                cpu: 100m
              limits:
                memory: 512Mi
                cpu: 200m
            storageSpec:
              volumeClaimTemplate:
                spec:
                  storageClassName: managed-premium
                  accessModes: ["ReadWriteOnce"]
                  resources:
                    requests:
                      storage: 5Gi
          service:
            type: LoadBalancer

        alertmanager:
          enabled: true
          service:
            type: LoadBalancer
          
        nodeExporter:
          enabled: true

        kubeStateMetrics:
          enabled: true
        EOF

        # התקנת סטאק Prometheus באמצעות קובץ הערכים המעודכן
        helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
          -f ./helm/monitoring/azure-values.yaml \
          --namespace monitoring

        echo "Waiting for Prometheus components to be ready..."
        kubectl wait --for=condition=ready pod -l app=prometheus -n monitoring --timeout=180s || true
        kubectl wait --for=condition=ready pod -l app=grafana -n monitoring --timeout=180s || true

        GRAFANA_PASSWORD=$(kubectl get secret -n monitoring prometheus-grafana -o jsonpath="{.data.admin-password}" | base64 --decode)
        GRAFANA_IP=$(kubectl get svc -n monitoring prometheus-grafana -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Grafana can be accessed at: http://$GRAFANA_IP"
        echo "Username: admin"
        echo "Password: $GRAFANA_PASSWORD"

    - name: Add Helm Repository
      run: |
        helm repo add orel-charts https://OrelNeto-DO.github.io/helm-charts
        helm repo update

    - name: Install Ingress Controller
      run: |
        # הוספת מאגר Ingress-NGINX ועדכון
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        # יצירת namespace ל-Ingress Controller
        kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -
        # התקנה/עדכון של Ingress Controller
        helm upgrade --install nginx-ingress ingress-nginx/ingress-nginx --namespace ingress-nginx
        
        # המתנה להכנת ה-Ingress Controller
        echo "Waiting for ingress controller to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/component=controller -n ingress-nginx --timeout=180s || true
        
        # קבלת ה-IP החיצוני של ה-Ingress Controller לשימוש מאוחר יותר
        INGRESS_CONTROLLER_IP=$(kubectl get svc -n ingress-nginx nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Ingress Controller IP: $INGRESS_CONTROLLER_IP"
        
        # עדכון ה-Ingress Host עם ה-IP האמיתי
        if [ -n "$INGRESS_CONTROLLER_IP" ]; then
          # נשמור את ה-IP לשימוש בהמשך
          echo "INGRESS_IP=$INGRESS_CONTROLLER_IP" >> $GITHUB_ENV
        fi

    - name: Deploy GifApp
      run: |
        echo "Deploying GifApp using GitOps configuration from values file"
        
        # קבלת ה-IP לשימוש ב-Ingress
        INGRESS_IP="${{ env.INGRESS_IP }}"
        echo "Using Ingress IP: $INGRESS_IP"
        
        # שימוש בקובץ הערכים לניהול מלא של ההגדרות ועדכון ה-Ingress host
        helm upgrade --install gifapp orel-charts/gif-app \
          --namespace gifapp --create-namespace \
          -f helm/gif-app/values.yaml \
          --set ingress.hosts[0].host="$INGRESS_IP.nip.io"
        
        # ****** תיקון הבעיה בשירות ******
        echo "Updating service selector to match pod labels..."
        kubectl patch svc -n gifapp gif-app-gifapp-flask --type='json' -p='[{"op": "replace", "path": "/spec/selector", "value": {"app": "flask-app"}}]'
        
        # ****** יצירת המשאבים עם השם הנכון שה-Pod מצפה לו ******
        echo "Creating necessary ConfigMap and Secret with the correct names..."
        
        # יצירת ConfigMap עם השם הנכון שה-Pod מחפש
        kubectl get configmap gifapp-flask-config -n gifapp -o yaml | \
          sed 's/name: gifapp-flask-config/name: gif-app-gifapp-flask-config/' | \
          kubectl apply -f -
        
        # יצירת Secret עם השם הנכון שה-Pod מחפש
        kubectl get secret gifapp-mysql-secrets -n gifapp -o yaml | \
          sed 's/name: gifapp-mysql-secrets/name: gif-app-gifapp-mysql-secrets/' | \
          kubectl apply -f -
        
        # ****** תצורת מסד הנתונים ******
        echo "Configuring database user and credentials..."
        
        # המתנה עד שהפוד של MySQL יהיה מוכן
        kubectl wait --for=condition=ready pod -l app=mysql -n gifapp --timeout=180s || true
        
        # יצירת משתמש במסד הנתונים
        kubectl exec -n gifapp $(kubectl get pods -n gifapp -l app=mysql -o jsonpath='{.items[0].metadata.name}') -- \
          mysql -u root -p'rootpassword' -e "CREATE USER IF NOT EXISTS 'gifuser'@'%' IDENTIFIED BY 'rootpassword'; GRANT ALL PRIVILEGES ON mydatabase.* TO 'gifuser'@'%'; FLUSH PRIVILEGES;"
        
        # עדכון ה-ConfigMap - עדכון משתני הסביבה
        kubectl patch configmap -n gifapp gif-app-gifapp-flask-config --type=merge -p '{"data":{"DB_HOST":"gifapp-mysql.gifapp.svc.cluster.local","DB_USER":"gifuser","DB_PASSWORD":"rootpassword"}}'
        
        # עדכון ה-Secret - עדכון הסיסמה במקרה שהיא שונה
        kubectl patch secret -n gifapp gif-app-gifapp-mysql-secrets --type='json' -p='[{"op": "replace", "path": "/data/DB_PASSWORD", "value": "'$(echo -n "rootpassword" | base64)'"}]'
        
        # מחיקת הפודים הקיימים כדי שייווצרו מחדש עם הקונפיגורציה הנכונה
        kubectl delete pods -n gifapp -l app=flask-app

    - name: Verify Deployment
      run: |
        echo "Waiting for pods to be ready..."
        # המתנה ארוכה יותר כדי לאפשר לפודים להתחיל מחדש
        kubectl wait --for=condition=ready pods --selector=app=flask-app -n gifapp --timeout=300s || true
        
        # הצגת סטטוס המשאבים
        echo "Checking pods status:"
        kubectl get pods -n gifapp
        
        echo "Checking endpoints for the service (should show active endpoints):"
        kubectl get endpoints -n gifapp gif-app-gifapp-flask
        
        echo "Checking ConfigMaps:"
        kubectl get configmaps -n gifapp
        
        echo "Checking Secrets:"
        kubectl get secrets -n gifapp
        
        echo "Checking services:"
        kubectl get services -n gifapp
        
        echo "Checking ingress:"
        kubectl get ingress -n gifapp

        # קבלת שם ה-Ingress
        INGRESS_NAME=$(kubectl get ingress -n gifapp -o jsonpath='{.items[0].metadata.name}')
        echo "Found ingress with name: $INGRESS_NAME"
        
        if [ -n "$INGRESS_NAME" ]; then
          # קבלת ה-Host של ה-Ingress
          INGRESS_HOST=$(kubectl get ingress -n gifapp $INGRESS_NAME -o jsonpath='{.spec.rules[0].host}' 2>/dev/null)
          if [ -n "$INGRESS_HOST" ]; then
            echo "GifApp is accessible at: http://$INGRESS_HOST"
            echo "Testing application..."
            curl -s -m 10 -o /dev/null -w "%{http_code}" "http://$INGRESS_HOST" || echo "Failed to connect, but continuing"
          else
            echo "Ingress host not assigned yet. Please check manually later."
          fi
        else
          echo "No ingress resources found in the gifapp namespace."
        fi

        # אלטרנטיבה באמצעות Port-Forward
        echo "Alternatively, use port-forward to access the application:"
        echo "kubectl port-forward -n gifapp svc/gif-app-gifapp-flask 8080:80"
        echo "Then access http://localhost:8080"

    - name: Debug Ingress (If needed)
      if: always()
      run: |
        echo "Checking ingress controller status:"
        kubectl get pods -n ingress-nginx
        kubectl get svc -n ingress-nginx
        
        echo "Checking ingress resources:"
        kubectl get ingress -A
        
        echo "Checking Flask Pods Logs (for debugging):"
        kubectl logs -n gifapp -l app=flask-app --tail=50 || echo "Failed to get logs"
        
        echo "Checking Ingress Controller Logs (for debugging):"
        kubectl logs -n ingress-nginx -l app.kubernetes.io/component=controller --tail=50 || echo "Failed to get logs"
        
        echo "Checking Ingress Events:"
        kubectl get events -n gifapp --sort-by='.lastTimestamp' | grep Ingress || echo "No Ingress events found"
        
        echo "Checking Pod Events:"
        kubectl get events -n gifapp --sort-by='.lastTimestamp' | grep Pod || echo "No Pod events found"